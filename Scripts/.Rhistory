layer_dense(units = 1, activation = 'sigmoid')
model_nn_nosample2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_adam(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample2 <- model_nn_nosample2 %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 500),
validation_split = 0.2)
table(predicted = model_nn_nosample2 %>% predict_classes(x_train), true = y_train)
model_nn_nosample2 %>% evaluate(x_dev, y_dev)
table(predicted = model_nn_nosample2 %>% predict_classes(x_dev), true = y_dev)
model_nn_nosample2 <- keras_model_sequential()
model_nn_nosample2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_nn_nosample2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(lr = 0.0001),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample2 <- model_nn_nosample2 %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 500),
validation_split = 0.2)
table(predicted = model_nn_nosample2 %>% predict_classes(x_train), true = y_train)
model_nn_nosample2 %>% evaluate(x_dev, y_dev)
table(predicted = model_nn_nosample2 %>% predict_classes(x_dev), true = y_dev)
model_nn_nosample2 <- keras_model_sequential()
model_nn_nosample2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_nn_nosample2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(lr = 0.0001),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample2 <- model_nn_nosample2 %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 500),
validation_split = 0.2)
table(predicted = model_nn_nosample2 %>% predict_classes(x_train), true = y_train)
model_nn_nosample2 %>% evaluate(x_dev, y_dev)
table(predicted = model_nn_nosample2 %>% predict_classes(x_dev), true = y_dev)
model_nn_nosample2 <- keras_model_sequential()
model_nn_nosample2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_nn_nosample2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(lr = 0.0001),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample2 <- model_nn_nosample2 %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 500),
validation_split = 0.2)
table(predicted = model_nn_nosample2 %>% predict_classes(x_train), true = y_train)
model_nn_nosample2 %>% evaluate(x_dev, y_dev)
table(predicted = model_nn_nosample2 %>% predict_classes(x_dev), true = y_dev)
model_nn_nosample2 <- keras_model_sequential()
model_nn_nosample2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_nn_nosample2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(lr = 0.0001),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample2 <- model_nn_nosample2 %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 500),
validation_split = 0.2)
table(predicted = model_nn_nosample2 %>% predict_classes(x_train), true = y_train)
model_nn_nosample2 %>% evaluate(x_dev, y_dev)
table(predicted = model_nn_nosample2 %>% predict_classes(x_dev), true = y_dev)
table(predicted = model %>% predict_classes(x_train), true = y_train)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
summary(model_nn_nosample2)
# Scale the dev set (using scaling parameters from the training set)
credit_test_scaled <- credit_test %>%
mutate(
Amount = (Amount - mean(credit_train_nosample$Amount)) /
sd(credit_train_nosample$Amount),
time_of_day = (time_of_day - mean(credit_train_nosample$time_of_day)) /
sd(credit_train_nosample$time_of_day))
# Convert to matrix
x_test <- as.matrix(subset(credit_test_scaled, select = -c(Class, Time)))
y_test <- as.integer(credit_test_scaled$Class) - 1    # Scales numerics back to 0/1
model_nn_nosample2 %>% evaluate(x_test, y_test)
table(predicted = model_nn_nosample2 %>% predict_classes(x_test), true = y_test)
library(keras)
# Scale the training data
credit_train_oversampled_scaled <- credit_train_oversampled %>%
mutate(Amount = (Amount - mean(Amount)) / sd(Amount),
time_of_day = (time_of_day - mean(time_of_day)) / sd(time_of_day))
# Convert to matrix
x_train <- as.matrix(subset(credit_train_oversampled_scaled, select = -c(Class, Time)))
y_train <- as.integer(credit_train_oversampled_scaled$Class) - 1    # Scales numerics back to 0/1
# Scale the dev set (using scaling parameters from the training set)
credit_dev_scaled <- credit_dev %>%
mutate(
Amount = (Amount - mean(credit_train_oversampled$Amount)) /
sd(credit_train_oversampled$Amount),
time_of_day = (time_of_day - mean(credit_train_oversampled$time_of_day)) /
sd(credit_train_oversampled$time_of_day))
# Convert to matrix
x_dev <- as.matrix(subset(credit_dev_scaled, select = -c(Class, Time)))
y_dev <- as.integer(credit_dev_scaled$Class) - 1    # Scales numerics back to 0/1
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample1 <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
table(predicted = model %>% predict_classes(x_train), true = y_train)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(lr = 0.01),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample1 <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
table(predicted = model %>% predict_classes(x_train), true = y_train)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample1 <- model %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
table(predicted = model %>% predict_classes(x_train), true = y_train)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample1 <- model %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 500),
validation_split = 0.2)
table(predicted = model %>% predict_classes(x_train), true = y_train)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
fit_nn_nosample1 <- model %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 50),
validation_split = 0.2)
table(predicted = model %>% predict_classes(x_train), true = y_train)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample1 <- model %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
table(predicted = model %>% predict_classes(x_train), true = y_train)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
model_oversampled2 <- keras_model_sequential()
model_oversampled2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_oversampled2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample1 <- model_oversampled2 %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
model %>% evaluate(x_dev, y_dev)
table(predicted = model %>% predict_classes(x_dev), true = y_dev)
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn_nosample1 <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
fit_nn_nosample1
fit_nn_nosample1$params
fit_nn_nosample1$metrics
model <- keras_model_sequential(verbose = 0)
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2,
verbose = 0)
model_oversampled2 <- keras_model_sequential()
model_oversampled2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_oversampled2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model_oversampled2 %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2,
verbose = 0)
table(predicted = model_oversampled2 %>% predict_classes(x_train), true = y_train)
model_oversampled2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model_oversampled2 %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2,
verbose = 2)
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
library(keras)
# Scale the training data
credit_train_oversampled_scaled <- credit_train_oversampled %>%
mutate(Amount = (Amount - mean(Amount)) / sd(Amount),
time_of_day = (time_of_day - mean(time_of_day)) / sd(time_of_day))
# Convert to matrix
x_train <- as.matrix(subset(credit_train_oversampled_scaled, select = -c(Class, Time)))
y_train <- as.integer(credit_train_oversampled_scaled$Class) - 1    # Scales numerics back to 0/1
# Scale the dev set (using scaling parameters from the training set)
credit_dev_scaled <- credit_dev %>%
mutate(
Amount = (Amount - mean(credit_train_oversampled$Amount)) /
sd(credit_train_oversampled$Amount),
time_of_day = (time_of_day - mean(credit_train_oversampled$time_of_day)) /
sd(credit_train_oversampled$time_of_day))
# Convert to matrix
x_dev <- as.matrix(subset(credit_dev_scaled, select = -c(Class, Time)))
y_dev <- as.integer(credit_dev_scaled$Class) - 1    # Scales numerics back to 0/1
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
model_oversampled2 <- keras_model_sequential()
model_oversampled2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_oversampled2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model_oversampled2 %>%
fit(x_train,
y_train,
epochs = 50,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
library(keras)
# Scale the training data
credit_train_nosample_scaled <- credit_train_nosample %>%
mutate(Amount = (Amount - mean(Amount)) / sd(Amount),
time_of_day = (time_of_day - mean(time_of_day)) / sd(time_of_day))
# Convert to matrix
x_train <- as.matrix(subset(credit_train_nosample_scaled, select = -c(Class, Time)))
y_train <- as.integer(credit_train_nosample_scaled$Class) - 1    # Scales numerics back to 0/1
# Scale the dev set (using scaling parameters from the training set)
credit_dev_scaled <- credit_dev %>%
mutate(
Amount = (Amount - mean(credit_train_nosample$Amount)) /
sd(credit_train_nosample$Amount),
time_of_day = (time_of_day - mean(credit_train_nosample$time_of_day)) /
sd(credit_train_nosample$time_of_day))
# Convert to matrix
x_dev <- as.matrix(subset(credit_dev_scaled, select = -c(Class, Time)))
y_dev <- as.integer(credit_dev_scaled$Class) - 1    # Scales numerics back to 0/1
model <- keras_model_sequential()
model %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 1),
validation_split = 0.2)
model_nn_nosample2 <- keras_model_sequential()
model_nn_nosample2 %>%
layer_dense(units = 16, activation = 'relu', input_shape = ncol(x_train),
kernel_initializer = 'uniform') %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = 'sigmoid')
model_nn_nosample2 %>% compile(
loss = 'binary_crossentropy',
optimizer = optimizer_rmsprop(lr = 0.0001),
metrics = c('accuracy'))
set.seed(123456)
fit_nn <- model_nn_nosample2 %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
class_weight = list('0' = 1, '1' = 500),
validation_split = 0.2)
table(predicted = model_nn_nosample2 %>% predict_classes(x_train), true = y_train)
model_nn_nosample2 %>% evaluate(x_dev, y_dev)
table(predicted = model_nn_nosample2 %>% predict_classes(x_dev), true = y_dev)
